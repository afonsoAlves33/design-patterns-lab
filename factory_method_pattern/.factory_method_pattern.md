# Factory Method Pattern

The **Factory Method Pattern** is a creational design pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created.

---

## üß† Intent

> Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

---

## üì¶ Participants

- **Creator**: Declares the factory method and may define a default implementation that returns a default product. It can also include other operations that use the product.

- **ConcreteCreator**: Overrides the factory method to return an instance of a ConcreteProduct.

- **Product**: Declares the interface of objects the factory method creates.

- **ConcreteProduct**: Implements the Product interface.

---

## üîÑ Structure

```text
+----------------+          +-----------------+
|    Creator     |<>--------|    Product      |
|----------------|          |-----------------|
| + factoryMethod()         |                 |
| + someOperation()         |                 |
+----------------+          +-----------------+
        ^                             ^
        |                             |
+-------------------+       +---------------------+
| ConcreteCreator   |       |   ConcreteProduct   |
|-------------------|       |---------------------|
| + factoryMethod() |       |  implements Product |
+-------------------+       +---------------------+
```

---

## üåê Example in Python

```python
from abc import ABC, abstractmethod

# Product Interface
class Button(ABC):
    @abstractmethod
    def render(self):
        pass

# Concrete Products
class WindowsButton(Button):
    def render(self):
        return "Render a button in Windows style"

class MacButton(Button):
    def render(self):
        return "Render a button in macOS style"

# Creator
class Dialog(ABC):
    @abstractmethod
    def create_button(self) -> Button:
        pass

    def render_window(self):
        button = self.create_button()
        return button.render()

# Concrete Creators
class WindowsDialog(Dialog):
    def create_button(self) -> Button:
        return WindowsButton()

class MacDialog(Dialog):
    def create_button(self) -> Button:
        return MacButton()

# Client code
for dialog in [WindowsDialog(), MacDialog()]:
    print(dialog.render_window())
```

---

## ‚öñÔ∏è When to Use

- When you don't know beforehand the exact types and dependencies of the objects your code should work with.
- When you want to provide users of your library or framework with a way to extend its internal components.
- When you want to localize the knowledge of which helper subclass is the delegate.

---

## üìÖ Real-World Examples

- GUI libraries where you have different themes: Windows, macOS, Linux.
- Document creation apps that support different types of files (PDF, Word, HTML).
- Game engines that instantiate different types of enemies or levels depending on the game mode.

---

## üîÑ Related Patterns

- **Abstract Factory**: Often implemented using Factory Methods. Provides an interface to create families of related or dependent objects.
- **Template Method**: Relies on inheritance; Factory Method relies on object composition through interfaces.
- **Prototype**: Relies on cloning pre-built objects rather than subclassing or instantiating new ones.

